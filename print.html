<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>算法设计与分析学习笔记</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="230914.html"><strong aria-hidden="true">1.</strong> 基础知识1.1~1.9(1)</a></li><li class="chapter-item expanded "><a href="230921.html"><strong aria-hidden="true">2.</strong> 基础知识1.1~1.9(2)</a></li><li class="chapter-item expanded "><a href="230928.html"><strong aria-hidden="true">3.</strong> 国庆假期作业</a></li><li class="chapter-item expanded "><a href="231007.html"><strong aria-hidden="true">4.</strong> 基础知识2.1~2.7</a></li><li class="chapter-item expanded "><a href="231012.html"><strong aria-hidden="true">5.</strong> 基础知识2.8~分治策略3.5</a></li><li class="chapter-item expanded "><a href="231019.html"><strong aria-hidden="true">6.</strong> 幂乘算法及其应用3.6~4.5选择问题的算法分析</a></li><li class="chapter-item expanded "><a href="231026.html"><strong aria-hidden="true">7.</strong> 动态规划算法的例子5.2~动态规划算法的迭代实现5.5</a></li><li class="chapter-item expanded "><a href="231030.html"><strong aria-hidden="true">8.</strong> 最长公共子序列5.8</a></li><li class="chapter-item expanded "><a href="231106.html"><strong aria-hidden="true">9.</strong> 两个问题</a></li><li class="chapter-item expanded "><a href="231113.html"><strong aria-hidden="true">10.</strong> 贪心法的设计思想4.1~对贪心法得不到最优解情况的处理4.3</a></li><li class="chapter-item expanded "><a href="231120.html"><strong aria-hidden="true">11.</strong> 贪心法</a></li><li class="chapter-item expanded "><a href="231128.html"><strong aria-hidden="true">12.</strong> 回溯算法</a></li><li class="chapter-item expanded "><a href="231204.html"><strong aria-hidden="true">13.</strong> 线性规划</a></li><li class="chapter-item expanded "><a href="231211.html"><strong aria-hidden="true">14.</strong> 网络流算法</a></li><li class="chapter-item expanded "><a href="231219.html"><strong aria-hidden="true">15.</strong> 算法分析与问题的计算复杂度</a></li><li class="chapter-item expanded "><a href="231225.html"><strong aria-hidden="true">16.</strong> NP完全性</a></li><li class="chapter-item expanded "><a href="note-1.html"><strong aria-hidden="true">17.</strong> 基础知识学习笔记</a></li><li class="chapter-item expanded "><a href="note-3.html"><strong aria-hidden="true">18.</strong> 动态规划学习笔记</a></li><li class="chapter-item expanded "><a href="note-4.html"><strong aria-hidden="true">19.</strong> 贪心法学习笔记</a></li><li class="chapter-item expanded "><a href="note-6.html"><strong aria-hidden="true">20.</strong> 线性规划学习笔记</a></li><li class="chapter-item expanded "><a href="final-exam-review1.html"><strong aria-hidden="true">21.</strong> 期末复习题（1）</a></li><li class="chapter-item expanded "><a href="final-exam-review2.html"><strong aria-hidden="true">22.</strong> 期末复习题（2）</a></li><li class="chapter-item expanded "><a href="final-exam-points.html"><strong aria-hidden="true">23.</strong> 期末复习重点</a></li><li class="chapter-item expanded "><a href="final-exam-review3.html"><strong aria-hidden="true">24.</strong> 期末复习笔记（1）</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">算法设计与分析学习笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>一、课程主要内容</p>
<p><img src="https://vip2.loli.io/2023/09/14/UcAebSnJOHPa8RW.webp" alt="" /></p>
<p>二、本节课的主要内容</p>
<p><img src="https://vip2.loli.io/2023/09/14/2UX4wuavthDNZCH.webp" alt="" /></p>
<p>三、算法设计的要点</p>
<p><img src="https://vip2.loli.io/2023/09/14/pZVkQmdsGRbl4qH.webp" alt="" /></p>
<p>四、本节课涉及的问题</p>
<ul>
<li>
<p>货郎问题</p>
</li>
<li>
<p>0-1背包问题</p>
</li>
<li>
<p>双机调度问题</p>
</li>
<li>
<p>NP-hard问题</p>
</li>
</ul>
<p><img src="https://vip2.loli.io/2023/09/14/KvhwMZWxic8rBNl.webp" alt="" /></p>
<ul>
<li>.......</li>
</ul>
<p>五、货郎问题</p>
<p>注：课后作业要用到。</p>
<p><img src="https://vip2.loli.io/2023/09/14/6OYavZ2cfAJVETF.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/09/14/Hr5cKaY2N8kLxUl.webp" alt="" /></p>
<p>六：算法的两种时间复杂度</p>
<p>最坏时间复杂度和平均时间复杂度。</p>
<p><img src="https://vip2.loli.io/2023/09/14/ncWLdkXtU2B7g3I.webp" alt="" /></p>
<p>七、算法的伪代码描述</p>
<p><img src="https://vip2.loli.io/2023/09/14/f9LVUwrFC5PAgRN.webp" alt="" /></p>
<p>八、函数的渐近的界</p>
<ul>
<li>大O符号（描述一个函数的“上界”）</li>
</ul>
<p><img src="https://vip2.loli.io/2023/09/14/Vck1Ew9dWMo8U7K.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/09/14/6ro94VvIYeNq5ab.webp" alt="" /></p>
<ul>
<li>Ω符号（描述一个函数的“下界”）</li>
</ul>
<p><img src="https://vip2.loli.io/2023/09/14/9kjuNTpUiwW3AsQ.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/09/14/DvLnB1jXyYFoZu4.webp" alt="" /></p>
<ul>
<li>小o符号（描述一个更“严格”的上界）</li>
</ul>
<p><img src="https://vip2.loli.io/2023/09/14/DyjFRrNfZsVnGci.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/09/14/oq7ydfetbZ2pa5L.webp" alt="" /></p>
<ul>
<li>小w符号（描述一个更“严格”的下界）</li>
</ul>
<p><img src="https://vip2.loli.io/2023/09/14/3kuDgz8F1PWCISn.webp" alt="" /></p>
<p>课后作业</p>
<p>用python或java简单实现货郎问题(TSP,Traveling Salesman Problem)。</p>
<p><img src="https://vip2.loli.io/2023/09/19/jmlkoYL5Hni7pPK.webp" alt="" /></p>
<pre><code class="language-python">from itertools import permutations  # 导入排列函数

# 定义城市和它们之间的距离
cities = [&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;]
distances = {
    (&quot;c1&quot;, &quot;c2&quot;): 10,
    (&quot;c1&quot;, &quot;c3&quot;): 5,
    (&quot;c1&quot;, &quot;c4&quot;): 9,
    (&quot;c2&quot;, &quot;c3&quot;): 6,
    (&quot;c2&quot;, &quot;c4&quot;): 9,
    (&quot;c3&quot;, &quot;c4&quot;): 3,
}


# 函数：计算给定路径的总距离
def calculate_distance(path, distances):
    total_distance = 0  # 初始化总距离为0
    for i in range(len(path) - 1):  # 遍历路径中的每一对相邻城市
        # 使用get方法从字典中提取城市对的距离，如果没有则尝试反向城市对
        total_distance += distances.get(
            (path[i], path[i + 1]), distances.get((path[i + 1], path[i]), 0)
        )
    return total_distance  # 返回总距离


# 生成所有可能的路径（排列）
all_paths = list(permutations(cities))

# print(all_paths)
# print(len(all_paths))

# 寻找具有最小距离的路径
min_distance = float(&quot;inf&quot;)  # 初始化最小距离为无穷大
min_path = None  # 初始化最短路径为None

# 遍历所有可能的路径
for path in all_paths:
    path_with_return = path + (path[0],)  # 在路径末尾添加起始城市，形成一个回路
    distance = calculate_distance(path_with_return, distances)  # 计算回路的总距离
    if distance &lt; min_distance:  # 如果找到更短的路径，则更新最小距离和最短路径
        min_distance = distance
        min_path = path_with_return

# 输出最短路径和其总距离
print(min_path, min_distance)
</code></pre>
<p><img src="https://vip2.loli.io/2023/09/14/4jUJ1REFGVXwDiz.webp" alt="" /></p>
<p>九、补充</p>
<p>教材—<a href="https://ftp.gujiakai.top/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">算法设计与分析（第2版）</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>一、θ符号（同阶）</p>
<p><img src="https://vip2.loli.io/2023/09/21/qvci2lt7mOHodn9.webp" alt="" /></p>
<p>二、小w符号（描述算法复杂性的渐进下界）</p>
<p><img src="https://vip2.loli.io/2023/09/21/5N8BcdzWtxH4UPS.webp" alt="" /></p>
<p>三、有关函数渐近的界的定理（定理1）</p>
<p><img src="https://vip2.loli.io/2023/09/21/1ZDiJsCbneg7jOU.webp" alt="" /></p>
<p>四、一些重要的结果</p>
<p><img src="https://vip2.loli.io/2023/09/21/j7rZVR69kpfCE58.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/09/21/AnWuPO2rx4ecvyh.webp" alt="" /></p>
<p>五、有关函数渐近的界的定理（定理2）</p>
<p><img src="https://vip2.loli.io/2023/09/21/ym6tOAVlXjC9ocd.webp" alt="" /></p>
<p>六、有关函数渐近的界的定理（定理3）</p>
<p><img src="https://vip2.loli.io/2023/09/21/BG4dVJfYSepKAHP.webp" alt="" /></p>
<p>七、小结</p>
<p><img src="https://vip2.loli.io/2023/09/21/UsBTt46JZ7hMYKk.webp" alt="" /></p>
<p>八、基本函数类</p>
<p><img src="https://vip2.loli.io/2023/09/21/rUHt8OX96ksGeRb.webp" alt="" /></p>
<p>九、对数函数</p>
<p><img src="https://vip2.loli.io/2023/09/21/7hcAGVJa1UMtWC2.webp" alt="" /></p>
<p>十、指数函数和阶乘</p>
<p><img src="https://vip2.loli.io/2023/09/21/lUDBWO5rnGM4vyu.webp" alt="" /></p>
<p>十一、取整函数</p>
<p><img src="https://vip2.loli.io/2023/09/21/vBCqEXyuhbKiPe9.webp" alt="" /></p>
<p>十二、取整函数的性质</p>
<p><img src="https://vip2.loli.io/2023/09/21/3jivXza7UZq8TA4.webp" alt="" /></p>
<p>十三、例题，按照阶排序</p>
<p><img src="https://vip2.loli.io/2023/09/21/REafDNiBldIYjTm.webp" alt="" /></p>
<p>十四、数列求和公式</p>
<p><img src="https://vip2.loli.io/2023/09/21/nxW4YFbyPOcJtgh.webp" alt="" /></p>
<p>十五、二分检索平均时间复杂度</p>
<p><img src="https://vip2.loli.io/2023/09/21/AjTB7aZVkho8F4O.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>一、国庆作业</p>
<p><img src="https://vip2.loli.io/2023/09/28/b5Siso7FH6AQxlc.webp" alt="" /></p>
<p>汉诺塔（港台：河内塔）（Tower of Hanoi）是根据一个传说形成的数学问题：</p>
<p>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<p>每次只能移动一个圆盘；大盘不能叠在小盘上面。</p>
<p>解题思路：</p>
<p><img src="https://vip2.loli.io/2023/09/28/UoYbuMF8wZHfdkp.webp" alt="" /></p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1SP4y137E9">via</a></li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 汉诺塔递归函数
void hanoi(int n, char A, char B, char C) {
    // 当只有一个盘子时，直接从 A 移动到 C
    if (n == 1) {
        printf(&quot;Move disk 1 from %c to %c\n&quot;, A, C);
        return;
    }
    // 先将 n-1 个盘子从 A 移动到 B，以 C 作为中间塔
    hanoi(n-1, A, C, B);
    // 移动第 n 个盘子从 A 到 C
    printf(&quot;Move disk %d from %c to %c\n&quot;, n, A, C);
    // 最后将 n-1 个盘子从 B 移动到 C，以 A 作为中间塔
    hanoi(n-1, B, A, C);
}

int main() {
    // 初始化盘子数量为 3
    int n = 3;
    // 输出汉诺塔移动步骤
    printf(&quot;Hanoi Tower moves:\n&quot;);
    // 调用 hanoi 函数进行汉诺塔问题求解
    hanoi(n, 'A', 'B', 'C');
    return 0;
}
</code></pre>
<p>汉诺塔问题时间复杂度的分析：</p>
<p><img src="https://vip2.loli.io/2023/09/28/qTXpKn4jQZy7fBM.webp" alt="" /></p>
<p>插入排序的重要性质：</p>
<p><img src="https://vip2.loli.io/2023/09/28/bGSQOE29R7pwWyY.webp" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 插入排序函数
void insertionSort(int arr[], int n) {
    int i, j, key;
    // 从数组的第二个元素开始遍历
    for (i = 1; i &lt; n; i++) {
        // 当前待排序的元素
        key = arr[i];
        // 找到 key 应该插入的位置
        j = i - 1;
        // 将比 key 大的元素向后移动
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        // 将 key 插入到正确的位置
        arr[j + 1] = key;
    }
}

// 打印数组函数
void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d &quot;, arr[i]);
    }
    printf(&quot;\n&quot;);
}

int main() {
    // 初始化一个待排序的数组
    int arr[] = {12, 11, 13, 5, 6};
    // 计算数组长度
    int n = sizeof(arr) / sizeof(arr[0]);

    // 打印原始数组
    printf(&quot;Original array: \n&quot;);
    printArray(arr, n);

    // 进行插入排序
    insertionSort(arr, n);

    // 打印排序后的数组
    printf(&quot;Sorted array: \n&quot;);
    printArray(arr, n);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>一、估计和式上界的放大法</p>
<p><img src="https://vip2.loli.io/2023/10/07/9Pwbd5BeKgnYNx8.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/07/Fe6OcRN5tkQoBYa.webp" alt="" /></p>
<p>二、估计和式渐近的界</p>
<p><img src="https://vip2.loli.io/2023/10/10/vIqYH9EwR5ZXGBn.webp" alt="" /></p>
<p>三、递推方程</p>
<p><img src="https://vip2.loli.io/2023/10/08/uZBpOvzyRdcHP3w.webp" alt="" /></p>
<p>四、迭代法求解递推方程</p>
<p><img src="https://vip2.loli.io/2023/10/08/skRA1wnxT6j4zbO.webp" alt="" /></p>
<p>换元迭代：</p>
<p><img src="https://vip2.loli.io/2023/10/08/zQilIHXUyxbJAFo.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/08/pQN2ubw7fo9qAWP.webp" alt="" /></p>
<p>五、差消法化简高阶递推方程</p>
<p><img src="https://vip2.loli.io/2023/10/08/DE7le4UTyStkKdM.webp" alt="" /></p>
<p>六、递归树</p>
<p>一种用于分析递归算法时间复杂度的工具。它将递归过程展现为一棵树，从而我们可以很直观地看到每个递归层级的运算量。</p>
<p>七、主定理</p>
<p><img src="https://vip2.loli.io/2023/10/08/7kz9HBWcAXSp5Cq.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/08/nhPGlHZvkRtm7sN.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/08/XxfuCA6r75LgD3J.webp" alt="" /></p>
<p>八、GPT关于主定理的例子和解释</p>
<p><img src="https://vip2.loli.io/2023/10/08/6uElqAiWzo9yTDj.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/08/O7yHrFV4Rph3AnC.webp" alt="" /></p>
<p>九、主定理求解递归式的好处</p>
<p><img src="https://vip2.loli.io/2023/10/08/t1SaiH6lWqzoZDu.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>一、无法使用主定理求解递推方程时，可以使用递归树求解。</p>
<p>二、主定理求解递推方程的条件 &amp;&amp; 主定理什么时候可以用？</p>
<p><img src="https://vip2.loli.io/2023/10/12/wZpLVH8nWqX47ze.webp" alt="" /></p>
<p>三、大O符号表示小于等于</p>
<p><img src="https://vip2.loli.io/2023/10/14/7yAYH6oLxsIVu1C.webp" alt="" /></p>
<p>四、典型的分治算法</p>
<p><img src="https://vip2.loli.io/2023/10/14/xiK1vgj4YECmZ5p.webp" alt="" /></p>
<p>五、分治策略的基本思想</p>
<p><img src="https://vip2.loli.io/2023/10/14/woxAJ9zUhXvnWqr.webp" alt="" /></p>
<p>六、分治算法的特点</p>
<p><img src="https://vip2.loli.io/2023/10/14/HEYmlfcwt9Fqzvb.webp" alt="" /></p>
<p>七、两类常见的递推方程及其求解</p>
<p><img src="https://vip2.loli.io/2023/10/14/DlFtM8VBULQve6r.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/9UtqblXDnGPoTay.webp" alt="" /></p>
<p>八、方程2的解</p>
<p><img src="https://vip2.loli.io/2023/10/14/LPDqhsEI7ezTCOG.webp" alt="" /></p>
<p>九、芯片测试的分治算法</p>
<p><img src="https://vip2.loli.io/2023/10/14/Rs84zA63qNp1f2h.webp" alt="" /></p>
<p>十、分治策略中的快速排序</p>
<p><img src="https://vip2.loli.io/2023/10/14/adJFuRT7NPDjK8I.webp" alt="" /></p>
<p>课后作业：习题一</p>
<p><img src="https://vip2.loli.io/2023/10/14/FRMViTx5khH64uY.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/Wa6gUkiXs4BlGwH.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/tTYDrROXfjnFHyu.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/ZbkQpPHwtJnE2go.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/cbOHx7GihmLAzER.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/rK7QhsocR8jbI9n.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/14/KmjbzxU9CGtqrSL.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>一、斐波那契数列的性质</p>
<p><img src="https://vip2.loli.io/2023/10/28/7ghJFMjiSAUnL1e.webp" alt="" /></p>
<p>二、幂乘算法小结</p>
<p><img src="https://vip2.loli.io/2023/10/28/Wj8o3mVGxeK4YOl.webp" alt="" /></p>
<p>三、改进分治算法的途径1：减少子问题数</p>
<p>减少子问题个数的依据</p>
<p><img src="https://vip2.loli.io/2023/10/28/l7IU9jVBmAcRtb6.webp" alt="" /></p>
<p>矩阵乘法的研究及应用和改进途径小结</p>
<p><img src="https://vip2.loli.io/2023/10/28/mnljPagIMZ3CWbH.webp" alt="" /></p>
<p>四、改进分治算法的途径2：增加预处理</p>
<p><img src="https://vip2.loli.io/2023/10/28/BGQd6OYgEvNnVZC.webp" alt="" /></p>
<p>五、选最大与最小</p>
<p><img src="https://vip2.loli.io/2023/10/28/OCmDGcNixIYMAPz.webp" alt="" /></p>
<p>六、选第二大</p>
<p>选第二大提高效率的途径</p>
<p><img src="https://vip2.loli.io/2023/10/28/sLKbzdv2ZOVSJ7A.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/28/ltFGiwjcuVP8Kxr.webp" alt="" /></p>
<p>七、一般选择问题的算法设计</p>
<p>选择第k小的算法：</p>
<p><img src="https://vip2.loli.io/2023/10/28/ihcISrPl7kAVyH6.webp" alt="" /></p>
<p>八、选择问题的算法分析</p>
<p><img src="https://vip2.loli.io/2023/10/28/5FBSqDaT1HAeyjV.webp" alt="" /></p>
<p>九、为啥选择第k小的算法，采用分治方法，分组时5个元素一组？3个元素一组或7个一组行不行？</p>
<p><img src="https://vip2.loli.io/2023/10/28/NTxsgO76tIh2pkJ.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>注：算法设计与分析课程更改到每周一下午567节课。地点：学友楼504</p>
<p>课堂作业</p>
<p><img src="https://vip2.loli.io/2023/10/28/dnukV5EsIjFS4mJ.webp" alt="" /></p>
<p>按课本实践。</p>
<p>一、动态规划算法的例子</p>
<p>动态规划算法中的算法设计</p>
<p><img src="https://vip2.loli.io/2023/10/28/YBpTW6RcPnru1Zj.webp" alt="" /></p>
<p>优化原则</p>
<p><img src="https://vip2.loli.io/2023/10/28/2PzgHo6I7NpiqRv.webp" alt="" /></p>
<p>注：</p>
<ul>
<li>
<p>不满足优化原则，不能用动态规划。</p>
</li>
<li>
<p>动态规划图中的u和d，分别代表up和down。</p>
</li>
</ul>
<p>小结：</p>
<p><img src="https://vip2.loli.io/2023/10/28/CzFWtbfhXiuxqTZ.webp" alt="" /></p>
<p>二、动态规划算法设计</p>
<p>矩阵相乘基本运算次数</p>
<p><img src="https://vip2.loli.io/2023/10/28/6lfzrIW2ck3nBAC.webp" alt="" /></p>
<p>动态规划算法和优化函数的递推方程</p>
<p><img src="https://vip2.loli.io/2023/10/28/RYJue9zQfUcFw6l.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/28/Gsgq52tYuROFkNW.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/28/69chZTarqKOmHAG.webp" alt="" /></p>
<p>小结</p>
<p><img src="https://vip2.loli.io/2023/10/28/QwGSjFYDZtIpbrR.webp" alt="" /></p>
<p>三、动态规划算法的递归实现</p>
<p><img src="https://vip2.loli.io/2023/10/28/ZNBF81iUtEgTVLe.webp" alt="" /></p>
<p>四、动态规划算法的迭代实现</p>
<p>迭代算法的关键</p>
<p><img src="https://vip2.loli.io/2023/10/28/bJca8ZvLt4fFRiN.webp" alt="" /></p>
<p>备忘录和标记函数</p>
<p><img src="https://vip2.loli.io/2023/10/28/lpEhbDZFL2CjM1i.webp" alt="" /></p>
<p><img src="https://vip2.loli.io/2023/10/28/Aab3djBH6VvIRyo.webp" alt="" /></p>
<p>如何理解标记函数和备忘录</p>
<p><img src="https://vip2.loli.io/2023/10/28/cPRwoAEJGXu7FSz.webp" alt="" /></p>
<p>递归实现动态规划算法和迭代实现动态规划算法两种实现的比较，及动态规划算法的要素</p>
<p><img src="https://vip2.loli.io/2023/10/28/49U6FCzRnOM7XjL.webp" alt="" /></p>
<p>动态规划（Dynamic Programming）</p>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<p>最长公共子序列5.8</p>
<div style="break-before: page; page-break-before: always;"></div><p>一、爬楼梯问题—动态规划</p>
<p>二、扑克牌问题</p>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<p>贪心法的设计思想4.1~对贪心法得不到最优解情况的处理4.3</p>
<p>2、课后作业</p>
<p>田忌赛马 研究如何构造贪心策略，做PPT讲解思路。</p>
<div style="break-before: page; page-break-before: always;"></div><p>1、预习作业</p>
<p><img src="https://vip2.loli.io/2023/11/21/xEWFkNgGZTtqJmB.webp" alt="" /></p>
<p>2、预习作业</p>
<ul>
<li>
<p>leetcode 51</p>
</li>
<li>
<p>百练poj 2754</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<ul>
<li>
<p>回溯算法</p>
</li>
<li>
<p>0-1背包问题</p>
</li>
</ul>
<p>2、预习作业</p>
<p><img src="https://vip2.loli.io/2023/11/30/gvnfuXY7DoFURdH.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂要点</p>
<ul>
<li>
<p>线性规划模型</p>
</li>
<li>
<p>整数线性规划的分支限界算法</p>
</li>
</ul>
<p>2、预习作业</p>
<pre><code class="language-bash">第7章 网络流算法

7.1 最大流问题
（*）7.1.1 网络流及其性质
（9）7.1.1 Ford-Fulkerson算法
（8）7.1.1 Dinic有效算法

7.2 最小流问题
（7）7.2.1 Floyd算法
（6）7.2.2 最小费用的负回路算法
（5）7.2.3 最小费用的最短路径算法

7.3 运输问题
（4）7.3.1 确定初始调运方案
（3）7.3.2 改进调运方案
（2）7.3.3 表上作业法

7.4 二部图匹配
（1）7.4.1 二部图的最大匹配
（0）7.4.2 赋权二部图的匹配

按（学号最后两位%10）的准备相关内容（PPT+讲解）
（*）：全员准备
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<ul>
<li>网络流算法</li>
</ul>
<p>2、课后作业</p>
<pre><code class="language-bash">第8章 算法分析与问题的计算复杂度

（*）8.1 平凡下界

（*）8.2 直接计数求解该问题所需要的最少运算

（*）8.3 决策树

（3）8.4 检索算法的时间复杂度分析

        8.5 排序算法的时间复杂度
（2）8.5.1 冒泡排序算法
（1）8.5.2 堆排序算法
（0）8.5.3 排序算法的决策树与算法累时间复杂度的下界

        8.6 选择算法的时间复杂度分析
（1）8.6.1 找最大和最小问题
（2）8.6.2 找第二大问题
（3）8.6.3 找中位数的问题

（0）8.7 通过规约确认问题计算复杂度的下界


按（座位号%4）准备相关内容（PPT+讲解）
（*）：全员准备
%：“求余”运算
</code></pre>
<p>3、期末考试形式：笔试</p>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<ul>
<li>算法分析与问题的计算复杂度</li>
</ul>
<p>2、预习作业</p>
<pre><code class="language-bash">第9章 NP完全性

（*）9.1 P类与NP类
        9.1.1 易解的问题与难解的问题
        9.1.2 判定问题
        9.1.3 NP类

（6）9.2 多项式实践变换与NP完全性
         9.2.1 多项式时间变换
         9.2.2 NP完全性及其性质
         9.2.3 Cook-Levin定理--第一个NP完全问题

        9.3 几个NP完全问题
（3）9.3.1 最大可满足性与三元可满足行
（2）9.3.2 定点覆盖、团与独立集
（1）9.3.3 哈密顿回路与货郎问题
（0）9.3.4 恰好覆盖
（5）9.3.5 子集和、背包、装箱与双机调度
（4）9.3.6 整数线性规划

按（座位号%7）的准备相关内容（PPT+讲解）
（*）：全员准备
%：“求余”运算
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>1、课堂关键字</p>
<ul>
<li>NP完全性</li>
</ul>
<p>2、提及到的期末复习考察重点</p>
<ul>
<li>
<p>分治问题</p>
</li>
<li>
<p>动态规划，状态转移方程</p>
</li>
<li>
<p>贪心算法</p>
</li>
<li>
<p>时间复杂度</p>
</li>
<li>
<p>6～9</p>
</li>
<li>
<p>期末会有难题：算法推导与实现</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基础知识学习笔记"><a class="header" href="#基础知识学习笔记">基础知识学习笔记</a></h2>
<p>1、如果函数f(n)的渐近的上界和下界相等，都是g(n)，这时称g(n)是f(n)的渐近的紧的界，或者称函数f(n)的阶是g(n)。同阶可称g(n)是f(n)的紧的界。</p>
<p>2、大O记号和小o记号的区别：</p>
<p>当f(n)=O(g(n))时，f(n)的阶可能低于g(n)的阶，也可能等于g(n)的阶，而f(n)=o(g(n))时，f(n)的阶只能低于g(n)的阶。因此f(n)=o(g(n))可以推出f(n)=O(g(n))，但是反过来不成立。</p>
<p><strong>3、主定理</strong></p>
<p><img src="https://cdn.sa.net/2023/12/26/T7s3uQbJWwFvcLa.webp" alt="" /></p>
<p>4、指数函数的阶高于多项式函数的阶，而多项式函数的阶高于对数函数的阶。</p>
<p>5、在没有明确说明的情况下，算法课程中的 &quot;log n&quot; 通常意味着二进制对数。</p>
<p>6、在使用主定理（Master Theorem）来分析递归算法的时间复杂度时，我们关注的是当问题规模n趋向于无穷大时，时间复杂度 T(n)的渐近行为。</p>
<p>7、递推方程不满足主定理的条件，可以使用递归树求解。</p>
<p>8、在递归算法的时间复杂度分析中常常用到主定理，其中a代表递归调用所产生的字问题个数，n/b代表这些字问题的规模，f(n)则代表调用前的操作及调用后把子问题的解组合成原问题的解的总工作量。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="动态规划学习笔记"><a class="header" href="#动态规划学习笔记">动态规划学习笔记</a></h2>
<p>1、动态规划就是：给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后把子问题的答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>
<p>关键词</p>
<ul>
<li>记忆化搜索</li>
</ul>
<p>2、动态规划入门思路：dfs暴力—&gt;记忆化搜索—&gt;动态规划（递推）</p>
<p>3、递归的过程：“归”的过程才是产生答案的过程，“递”的过程是 分解子问题的过程。</p>
<p>4、</p>
<p>“递&quot;--&gt; 自顶向下</p>
<p>“归”--&gt; 自底向上</p>
<p>5、递归搜索树的底是已知最小子问题的答案。</p>
<p>6、</p>
<p>记忆化搜索 = 暴力dfs +记录答案</p>
<p>递推的公式= dfs 向下递归的公式</p>
<p>递推数组的初始值 = 递归的边界</p>
<p>7、动态规划，偏向全局最优，贪心法偏向局部最优。</p>
<p>8、以下关于动态规划法的描述哪些是正确的？
A.将问题分解成多级或许多子问题，然后顺序求解子问题。
B.可以确保得到最佳解
C.前一个子问题的解为后一个子问题的求解提供有用的信息。
D.从问题某一初始或推测值出发，一步步的攀登给定目标。
E.尽可能快的去逼近更好的解，当达到某一步不能继续时终止。</p>
<p>答案：A、C、D、E</p>
<p>链接：https://www.nowcoder.com/questionTerminal/ad0b237fcfe1468fb8fdb24b135586ae</p>
<p>9、动态规划入门习题</p>
<p>https://www.luogu.com.cn/paste/xac615na</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="贪心法学习笔记"><a class="header" href="#贪心法学习笔记">贪心法学习笔记</a></h2>
<p>1、田忌赛马问题</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="线性规划学习笔记"><a class="header" href="#线性规划学习笔记">线性规划学习笔记</a></h2>
<p>1、</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="选择题"><a class="header" href="#选择题">选择题</a></h2>
<pre><code class="language-bash">1、算法必须具备输入、输出和（D）等4个特性。
A. 可行性和安全性
B．确定性和易读性
C. 有穷性和安全性
D. 有穷性和确定性
答案：D
解析：
算法是解决问题的一系列明确的步骤。要成为有效的算法，它必须具备几个关键特性：
输入：算法应有零个或多个输入。
输出：至少有一个输出，即算法的结果。
有穷性：这意味着算法必须在执行有限的步骤后终止。这是非常关键的，
因为如果一个算法永远不会结束，那么它就不能用来有效地解决实际问题。
算法必须保证在经过一定数量的步骤后能够达到结束状态，无论是成功找到答案还是确定无解。
确定性：算法的每一步骤都必须明确无误，不能有歧义。这意味着在相同的输入下，
算法应该产生相同的输出。

2、算法分析中，记号O表示（），记号Ω表示（A）
A.渐近下界
B.渐近上界
C.非渐近上界
D.非渐近下界
答案：B，A
解析：
大O表示法 (Big O Notation) - 表示渐近上界
大O表示法用于描述算法性能的上限。它代表了算法在最坏情况下的运行时间复杂度。
例如, 如果一个算法的时间复杂度为O(n²), 这意味着在最坏情况下，算法的运行
时间是输入大小的平方的函数。
大Ω表示法 (Big Omega Notation) - 表示渐近下界
大Ω表示法用于描述算法性能的下限。它代表了算法在最佳情况下的运行时间复杂度。
例如, 如果一个算法的时间复杂度为Ω(n), 这意味着在最佳情况下，算法的运行时
间至少与输入大小成正比。
这两种表示法帮助我们从两个不同的角度理解算法的性能：
大O描述了算法可能的最慢速度，而大Ω描述了算法可能的最快速度。
</code></pre>
<p>题2拓展补充：</p>
<pre><code class="language-bash">1、假设有两个函数 f(n) = n² 和 g(n) = n³，那么 g(n) 与 f(n) 的关系是什么？

答案：f(n) = O(g(n))
解析：
</code></pre>
<p><img src="https://cdn.sa.net/2023/12/26/kqVyX53eUfBtNHL.webp" alt="" /></p>
<pre><code class="language-bash">2、如果 h(n) = 3n + 2，j(n) = 5n，则 h(n) 和 j(n) 的关系是什么？
答案：h(n) = Θ(j(n))
解析
这两个函数的主导项都是线性的（即 n），所以它们的增长率相同。
因此，h(n) = Θ(j(n))，表示两者具有相同的渐近增长率。

3、对于函数 k(n) = n² + n 和 m(n) = 2n²，k(n) 是什么关系？

答案
k(n) = Θ(m(n))

解析
尽管 k(n) 包含一个 n² 和一个 n 项，但它的主导项是 n²，这与 m(n) = 2n² 的主导项相同。因此，这两个函数在增长率上是相似的，即 k(n) 和 m(n) 是同阶的，k(n) = Θ(m(n))。这意味着在大的输入值时，这两个函数的增长率相似。
</code></pre>
<p>补充资料</p>
<p><img src="https://cdn.sa.net/2023/12/26/36SsM4Td1hOx8Rg.webp" alt="" /></p>
<pre><code class="language-bash">3、假设某算法在输入规模为 n 时的计算时间为 T(n) = 3*2^n。在某台计算机上实现并完成该算法的时间为 t 秒。现有另一台计算机，其运行速度为第一台的 64 倍，那么在这台新机器上用同一算法在 t 秒内能解输入规模多大的问题？
A. n+8
B. n+6
C. n+7
D. n+5
答案：B
解析：
</code></pre>
<p><img src="https://cdn.sa.net/2023/12/26/hyixFMsekKBgNpV.webp" alt="" /></p>
<pre><code class="language-bash">4、设问题规模为 N 时，某递归算法的时间复杂度记为 T(N)，已知 T(1) = 1，T(N) = 2T(N/2) + N/2，用 O 表示的时间复杂度为（）。
A. O(logN)
B. O(N)
C. O(NlogN)
D. O(N^2logN)
答案：C
解析：涉及知识点—主定理
</code></pre>
<p><img src="https://cdn.sa.net/2023/12/26/oAZUnY5XC9clJTf.webp" alt="" /></p>
<h2 id="应用题"><a class="header" href="#应用题">应用题</a></h2>
<p>1、求解递推方程</p>
<p>T(n)=9T(n/3)+n</p>
<p><img src="https://cdn.sa.net/2023/12/26/WS6CubHwQgicVNK.webp" alt="" /></p>
<p>2、求解递推方程</p>
<p>T(n)=T(2n/3)+1</p>
<p><img src="https://cdn.sa.net/2023/12/26/4HuwOm5ArkxhPSf.webp" alt="" /></p>
<p>3、求解递推方程</p>
<p>T(n)=3T(n/4)+nlogn</p>
<p><img src="https://cdn.sa.net/2023/12/26/jgUQhrauzs237k6.webp" alt="" /></p>
<p>4、求解递推方程</p>
<p>T(n)=2T(n/2)+nlogn</p>
<p>用到递归树求解。</p>
<p>在递归算法的时间复杂度分析中，递归成本通常是不可以忽略的，它对于确定总的时间复杂度至关重要。然而，有时在递归树的分析中，如果非递归部分的成本显著高于递归部分的成本，那么在总的时间复杂度中非递归成本会成为主导项。</p>
<p><img src="https://cdn.sa.net/2023/12/26/RkjOMAw985yoFKP.webp" alt="" /></p>
<p><img src="https://cdn.sa.net/2023/12/26/bt3SYcWG8pCJgkT.webp" alt="" /></p>
<ol>
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/Ew2aDGSArfbYLiZ.webp" alt="" /></p>
<ol start="2">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/bxhnqJYt5Ty1mP7.webp" alt="" /></p>
<ol start="3">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/Z7iBOzD4Q6SJWXw.webp" alt="" /></p>
<ol start="4">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/grM3RyeAfXxlijk.webp" alt="" /></p>
<ol start="5">
<li></li>
</ol>
<p>答案貌似有问题。</p>
<ol start="6">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/9GcEZM8Q5VvOJPI.webp" alt="" /></p>
<ol start="7">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/HdTVZuoyh9gp8WC.webp" alt="" /></p>
<ol start="8">
<li></li>
</ol>
<p><img src="https://cdn.sa.net/2023/12/26/7jeMKkiwHJfLpDt.webp" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>期末复习题1</p>
<h2 id="1选择题"><a class="header" href="#1选择题">1、选择题</a></h2>
<pre><code class="language-bash">1.算法必须具备输入、输出和（  ）等 4 个特性。
A．可行性和安全性 B．确定性和易读性
C．有穷性和安全性 D．有穷性和确定性
答案：D
解析：
A选项提到的“可行性和安全性”，虽然重要，但并不是算法的基本特性。
B选项中的“易读性”，指的是代码的可读性和易于理解，这更多是编程实践的一个方面，而非算法本身的基本特性。
C选项同样提到了“安全性”，这并不属于算法的基本特性。
D选项提到了“有穷性和确定性”，这两个都是算法的基本特性。

2.算法分析中，记号 O 表示（ B ），记号Ω表示（ A ）
A.渐进下界 B.渐进上界
C.非紧上界 D.紧渐进界
答案：B、A
解析：
大O记号（O） - 渐进上界:
定义: 大O记号用于描述算法的最坏情况运行时间的上限。当我们说一个算法的时间复杂度是O(f(n))时，
我们的意思是：在最坏的情况下，该算法的运行时间不会超过f(n)的某个常数倍。
例子: 如果一个算法的运行时间是O(n²)，这意味着在最坏的情况下，它的运行时间增长率不会超过输入大小n的平方的某个倍数。
关键点: 这是一种对算法在最坏情况下性能的保守估计。

大Omega记号（Ω） - 渐进下界:
定义: 大Omega记号用于描述算法的最佳情况运行时间的下限。当我们说一个算法的时间复杂度是Ω(g(n))时，
我们的意思是：在最好的情况下，该算法的运行时间至少是g(n)的某个常数倍。
例子: 如果一个算法的运行时间是Ω(n)，这意味着在最好的情况下，它的运行时间增长率至少与输入大小n的某个倍数相同。
关键点: 这是一种对算法在最佳情况下性能的乐观估计。

如果函数f(n)的渐近的上界和下界相等，都是g(n)，则称g(n)是f(n)的渐近的紧的界。或称函数f(n)的阶是g(n)。

3.假设某算法在输入规模为 n 时的计算时间为 T(n)=3*2^n。在某台计算机上实现并
完成该算法的时间为 t 秒。现有另一台计算机，其运行速度为第一台的 64 倍，那
么在这台新机器上用同一算法在 t 秒内能解输入规模为多大的问题？（  ）
A．n+8 B．n+6
C．n+7 D．n+5
答案：B
解析：
</code></pre>
<p><img src="https://cdn.sa.net/2024/01/01/zgTeAKQM12BGYch.webp" alt="" /></p>
<pre><code class="language-bash">4.设 问 题 规 模 为 N 时 ， 某 递 归 算 法 的 时 间 复 杂 度 记 为 T(N) ， 已 知 T(1)=1 ，
T(N)=2T(N/2)+N/2，用 O 表示的时间复杂度为（  ）。
A．O(logN) B．O(N)
C．O(NlogN) D．O(N²logN)
答案：C
解析：
</code></pre>
<p><img src="https://cdn.sa.net/2023/12/26/oAZUnY5XC9clJTf.webp" alt="" /></p>
<pre><code class="language-bash">5.直接或间接调用自身的算法称为（ B ）。
A．贪心算法 B．递归算法
C．迭代算法 D．回溯法
答案：B
解析：
题目是关于一个特定类型的算法的定义：直接或间接调用自身的算法。这种算法的定义符合选项B - 递归算法。

递归算法（B）:
定义: 递归算法是一种在其定义中直接或间接调用自身的算法。在递归算法中，问题被分解成更小的、类似的子问题，直到达到一个基本案例，
这个基本案例可以直接解决而不需要进一步递归。
例子: 一个典型的例子是计算斐波那契数列或阶乘。
其他选项:
A. 贪心算法：它是一种在每一步选择当前最好的解决方案的算法，不回头考虑之前的选择。这种方法并不包含直接或间接调用自身的特性。
C. 迭代算法：迭代算法通过重复执行一系列操作来解决问题，但这些操作不包括调用算法本身。
D. 回溯法：虽然回溯法经常使用递归来实现，但它是一种特定的算法，用于在解决问题的过程中穷举所有可能的解决方案，并“回溯”以找到最优解。

6.Fibonacci 数列中，第 4 个和第 11 个数分别是（  ）。
A．5，89 B．3，89
C．5，144 D．3，144
答案：B
解析：
1 1 2 3 5 8 13 21 34 55 89。
注：标准斐波那契数列的前两个数字是1和1。

8.一个问题可用动态规划算法或贪心算法求解的关键特征是问题的（  ）。
A．重叠子问题 B．最优子结构性质
C．贪心选择性质 D．定义最优解
答案：B
解析：
重叠子问题（A）:
这是动态规划算法的一个关键特征。在动态规划中，问题被分解成子问题，这些子问题被多次解决。
动态规划通过存储这些子问题的解决方案来优化计算，避免重复工作。然而，这并非贪心算法的特征。

最优子结构性质（B）:
这是动态规划和贪心算法共有的关键特征。如果一个问题具有最优子结构性质，那么问题的最优解
可以通过其子问题的最优解来构造。在动态规划中，我们利用这个性质来构建整体解决方案。
在贪心算法中，我们假设通过局部最优选择（每一步都做出当前看来最好的选择）可以达到全局最优解。

贪心选择性质（C）:
这是贪心算法的特征，其中局部最优选择被假设为会导致全局最优解。然而，这并不是动态规划所特有的，
因为动态规划不依赖于单一的“贪心”选择；相反，它考虑了多种选择的可能性。

定义最优解（D）:
定义最优解是解决任何优化问题的基本步骤，不特定于动态规划或贪心算法。
综上所述，最适合作为动态规划和贪心算法共有的关键特征的是最优子结构性质（B）。
这表明这两种算法都依赖于通过组合子问题的最优解来构造整体问题的最优解。因此，答案是 B. 最优子结构性质。

9.下列哪个问题不用贪心法求解（  ）。
A．哈夫曼编码问题 B．单源最短路径问题
C．最大团问题 D．最小生成树问题
答案：C
解析：
哈夫曼编码问题 (A): 这是一个经典的使用贪心策略的问题。在构建哈夫曼树时，总是选择频率最低的两个节点合并。
这是一个典型的贪心选择。

单源最短路径问题 (B): 特别是当我们考虑到Dijkstra算法时，这个问题可以通过贪心法解决。在每一步中，
算法都会选择当前最短的路径扩展到未访问的节点。

最大团问题 (C): 这个问题通常不使用贪心策略来解决。最大团问题是一个NP完全问题，意味着没有已知的多
项式时间算法（包括贪心算法）能解决所有情况。通常需要使用回溯、分支界限或者近似算法。书本P127，回溯和分支限界中提及。

最小生成树问题 (D): 这个问题可以通过贪心算法解决，如Kruskal算法或Prim算法。
这些算法在每一步都选择最小权重的边，以构建最小生成树。

10.下列算法中通常以自底向上的方式求解最优解的是（  ）。
A．备忘录法 B．动态规划法
C．贪心法 D．回溯法
答案：B
解析：
备忘录法 (A): 这通常与动态规划相关，但它更多地采用自顶向下的方法。在备忘录法中，原问题被分解成更小的子问题，
并且结果被存储（或“记忆化”），以避免重复计算。尽管它涉及到子问题的解决，但这种方法的执行顺序是从顶部问题开始，
逐渐深入到子问题。

动态规划法 (B): 动态规划是一种解决复杂问题的方法，通过将问题分解成更简单的子问题，并构建这些子问题的解决方案，
从而解决整个问题。动态规划可以采用自底向上或自顶向下的方法，但在经典的动态规划实践中，自底向上的方法更为常见。
在这种方法中，我们首先解决最小的子问题，并逐步构建更大的问题的解决方案。

贪心法 (C): 贪心算法在每一步都做出当下看起来最好的选择，以期望这会导致全局最优解。这种方法通常不是自底向上的；
相反，它从某个初始解出发，通过局部最优的选择来扩展这个解。

回溯法 (D): 回溯法是一种解决问题的算法，通过尝试分步的方法逐步找到问题的解决方法。当它遇到一个问题没有解决方
案的情况时，它会回退一步尝试其他可能的解决方案。这更像是一种自顶向下的探索方法，而不是自底向上。

综上所述，答案是 B. 动态规划法。动态规划法在求解最优解时，通常采用自底向上的方法，首先解决最小的子问题，
然后逐步向上构建，直到解决原始问题。

11.下列算法中不能解决 0/1 背包问题的是（  ）。
A．贪心法 B．动态规划
C．回溯法 D．分支限界法
答案：A
解析：
贪心法 (A): 贪心算法在每一步都做出在当前看来最优的选择。在 0/1 背包问题中，贪心算法可能会根据价值
或价值密度（价值除以重量）来选择物品。然而，这种方法不能保证总是得到最优解，因为它可能错过了更优的
组合，这些组合可能在初看时并不是最优的。因此，贪心法并不总是适用于解决 0/1 背包问题。

动态规划 (B): 动态规划是解决 0/1 背包问题的经典方法。它通过构建一个解决子问题的表格，并从最简单的
子问题开始，逐步解决更复杂的问题，最终找到最优解。

回溯法 (C): 回溯法是一种通过遍历所有可能情况来找到问题所有解的算法。对于 0/1 背包问题，回溯法可以
通过尝试包括或不包括每个物品来找到所有可能的组合，从而找到最优解。

分支限界法 (D): 分支限界法是一种用于解决优化问题和计数问题的方法，它系统地遍历候选解的树形结构。
在 0/1 背包问题中，它可以有效地剪枝，从而只搜索有希望的分支，也能找到最优解。
因此，答案是 A. 贪心法，因为它不能保证总是解决 0/1 背包问题。贪心法可能会提供一个解，但这个解不一定是最优的。

12.下列哪个问题可以用贪心算法求解（ ）。
A．LCS 问题 B．批处理作业问题
C．0-1 背包问题 D．哈夫曼编码问题
答案：D
解析：
LCS 问题 (A): LCS (最长公共子序列，Longest Common Subsequence)问题是寻找两个序列共有的最长子序列的问题。
这个问题不能用贪心算法有效解决，因为贪心选择可能导致错过更长的公共子序列。通常使用动态规划来解决。

批处理作业问题 (B): 这个问题通常指的是在计算机科学中的作业调度问题，需要考虑作业的顺序以优化总体性能。
这个问题的解决方案通常不是贪心的，因为局部最优选择可能不会导致全局最优。

0-1 背包问题 (C): 正如前面提到的，0-1 背包问题不能用贪心算法有效解决，因为贪心选择可能导致非最优解。

哈夫曼编码问题 (D): 这是一个通过构建最优前缀编码树来最小化编码总长度的问题。哈夫曼算法是一个贪心算法的经典例子，
它在每一步选择最低频率的两个节点合并，这种贪心选择可以保证找到最优的前缀编码。

因此，答案是 D. 哈夫曼编码问题。这个问题可以用贪心算法求解，因为在每一步合并频率最低的两个节点这一贪心策略可以
保证最终得到最优的前缀编码

13.用回溯法求解最优装载问题时，若待选物品为 m 种，则该问题的解空间树的结点
个数为（ ）。 
A．m!  B．2^(m+1)
C．2^(m+1)-1  D．2^m
答案：
解析：
最优装载问题是一个典型的组合优化问题，可以通过回溯法来求解。在这个问题中，
我们需要决定哪些物品被装载以优化某个特定的目标（例如最大化价值或最小化重量）。

在用回溯法解决这类问题时，我们通常构建一个解空间树，其中每个节点代表一个决策
（装载或不装载某个物品）。对于 m 种待选物品，解空间树的每个层级代表对一个物
品的决策，每个物品有两种选择：装载或不装载。

A. m!: 这代表 m 种物品的所有排列，但在最优装载问题中，物品的排列顺序并不重要，重要的是哪些物品被选中。
因此，m! 不是解空间树节点数的正确表达。

B. 2^(m+1) 和 C. 2^(m+1)-1: 这两个选项都是基于二叉树的节点数计算的。在一个完全二叉树中，
如果树的高度为 h，那么它的节点总数是 2^h - 1（这是选项 C）。如果树的最后一层完全满了，那么节点总数
是 2^(h+1) - 1，这里 h = m，所以选项 C 是正确的。

D. 2^m: 这代表每个物品两种选择（装载或不装载）的所有可能组合。在一个有 m 个物品的问题中，
会有 2^m 种组合，但这只计算了树的叶子节点，没有包括决策树中的非叶子节点。

综上所述，答案是 C. 2^(m+1)-1。这是因为每个物品有两种选择（即二叉树），所以对于 m 种物品，
解空间树是一个高度为 m 的完全二叉树，其总节点数为 2^(m+1)-1。

14.二分搜索算法是利用（  ）实现的算法。
A．分治策略 B．动态规划法
C．贪心法 D．回溯法
答案：A
解析：
分治策略（A）：在二分搜索中，我们将问题分解为更小的子问题。具体来说，我们将数组分为两部分，
并确定所寻找的元素是在左侧还是右侧。通过这种方式，我们每次都将搜索范围减少一半，直到找到
目标元素或者确定元素不存在。这是分治法的一个典型应用，因为我们在每一步都将问题划分为两个更小的部分。

动态规划法（B）：与二分搜索不同，动态规划是解决具有重叠子问题和最优子结构的问题的方法。
它通常用于求解具有递推关系的问题，通过存储子问题的解来避免重复计算。二分搜索并不涉及重叠子问题或最优子结构的概念。

贪心法（C）：贪心算法在每一步都采取当前看起来最优的选择，而不考虑整体的最优解。二分搜索不是
在每一步都寻找局部最优解，而是通过比较和切分来系统地缩小搜索范围。

回溯法（D）：回溯算法是一种通过试错来寻找所有/某些解决方案的算法，当它通过尝试可能的分支找
到一个可能的解决方案时会回溯。二分搜索并不涉及试错或回溯；它是一种直接且系统的搜索方法。

因此，最适合描述二分搜索算法的是A. 分治策略。二分搜索通过不断地将问题分解为更小的部分，
并在每一步中减少搜索范围，直到找到答案或确定答案不存在。主人，这是二分搜索算法的基本解析。

15.下列不是动态规划算法基本步骤的是（  ）。
A．找出最优解的性质 B．构造最优解
C．算出最优解(应该是最优值) D．定义最优解
答案：A
解析：
要确定哪一个选项不是动态规划算法的基本步骤，我们需要回顾动态规划算法的关键特征和步骤：

定义子问题（D）：在动态规划中，首先需要定义子问题。这是基本步骤之一，
因为动态规划算法依赖于解决重叠的子问题并使用这些解来构建整体问题的解。

计算子问题的最优解（C）：这一步是动态规划中的核心。算法需要计算每个子问题的最优解，
并通常将这些解存储在一个表格中以避免重复计算。

构造最优解（B）：一旦所有子问题的最优解都被找到，动态规划算法会从这些子问题的解中
构建出整个问题的最优解。这个步骤对于完成整个算法过程至关重要。

找出最优解的性质（A）：这一步骤通常是指在解决问题之前理解问题的性质，例如最优子结构
和重叠子问题。虽然这对于设计一个有效的动态规划算法很重要，但它并不是动态规划算法本身的“步骤”，
而是解决问题之前的一个准备步骤。

综上所述，如果我们严格区分算法设计的准备工作和算法本身的执行步骤，那么可以认为“A. 找出最优解的性质”
并不直接属于动态规划算法的执行步骤，而是一个前期的准备或理论分析步骤。
因此，在这个上下文中，选项A可以被视为“不是动态规划算法基本步骤”的选项。

16.下面问题（  ）不能使用贪心法解决。
A．单源最短路径问题 B．N 皇后问题
C．最小花费生成树问题 D．哈夫曼编码问题
答案：B
解析：
在这个问题中，我们需要识别哪个问题不能使用贪心法解决。贪心算法是一种在每一步选择中都选取当前状态下最好的选择，
而不考虑以后可能产生的后果。这种方法对于某些问题来说是有效的，但对于其他问题则可能无法找到最优解。
让我们逐一分析这些选项：

单源最短路径问题（A）：对于没有负权边的图，贪心算法是有效的。例如，Dijkstra算法就是一个使用
贪心策略来寻找单源最短路径的算法。

N皇后问题（B）：这个问题要求在N×N的棋盘上放置N个皇后，使得它们互不攻击。这是一个典型的回溯
问题，因为你需要考虑所有皇后的放置方式来找到解决方案。贪心算法在这里不适用，因为在放置每个
皇后时，对当前棋盘最优的选择可能导致无法放置后续的皇后。

最小花费生成树问题（C）：这个问题可以使用贪心算法解决。最著名的例子是Kruskal算法和Prim算法，
它们都是使用贪心策略来找到最小生成树的。

哈夫曼编码问题（D）：这是一种压缩数据的方法，也是贪心算法的一个应用。在哈夫曼编码中，经常出现的
字符使用较短的编码，不常出现的字符使用较长的编码，这是一种典型的贪心选择方法。

综上所述，贪心法可以有效解决单源最短路径问题、最小花费生成树问题和哈夫曼编码问题。然而，对于N皇后
问题，贪心法由于其局限性（即在每一步都做局部最优选择）无法保证找到全局最优解。
因此，不能使用贪心法解决的问题是 B. N皇后问题。

17.用二分搜索算法在 n 个有序元素表中搜索一个特定元素，在最好情况和最坏情况
下搜索的时间复杂性分别为（  ）。
A．O(1)，O(logn)  B．O(n)，O(logn) 
C．O(1)，O(nlogn)  D．O(n)，O(nlogn)
答案：A
解析：
二分搜索算法是一种在有序元素表中查找特定元素的高效方法。这个算法的核心思想是将搜索区间分成两半，
然后根据目标元素与中间元素的比较结果来确定接下来搜索的区间。现在，让我们来探讨这个算法在最好
情况和最坏情况下的时间复杂度。

最好情况：在最好的情况下，我们要找的元素恰好是中间元素，也就是说，在第一次尝试时我们就找到了目标。
在这种情况下，时间复杂度是 O(1)，因为我们只进行了一次操作。

最坏情况：在最坏的情况下，每次比较都不会直接找到目标元素，我们需要不断地将搜索区间分成两半。
由于每次操作都将搜索区间减半，所以二分搜索的时间复杂度是 O(logn)。这意味着随着元素数量的增加，
所需的步骤数增加的速度是对数的。
所以，基于这些分析，我们可以看到选项 A（O(1)，O(logn)）是正确的答案。这个选项正确地描述了
二分搜索在最好情况下（即第一次就找到目标元素）和最坏情况下（即每次都需要将搜索区间分成两半
直到找到目标元素）的时间复杂度。

21.下列关于计算机算法的描述不正确的是（  ）。
A．算法是指解决问题的一种方法或一个过程
B．算法是若干指令的有穷序列
C. 算法必须要有输入和输出
D．算法是编程的思想
答案：C
解析：
A. 算法是指解决问题的一种方法或一个过程：这个描述是正确的。算法确实是一组定义清晰的指令集合，
用于解决特定的问题或执行特定的任务。

B. 算法是若干指令的有穷序列：这也是正确的。算法由一系列步骤组成，这些步骤有明确的开始和结束，
这意味着它们是有限的。

C. 算法必须要有输入和输出：这个描述是有争议的。大多数算法确实涉及输入和产生输出，但并非所有
算法都严格要求有输入。例如，某些算法可能只生成一系列数据（只有输出，没有输入），或者仅基于内
部状态执行操作（既无输入也无输出）。因此，这个描述可能被视为不完全正确。

D. 算法是编程的思想：这个说法是比较宽泛的。算法更准确地说，是解决问题的方法或步骤。它确实是编
程中一个重要的组成部分，但将算法仅描述为“编程的思想”可能过于简化了其定义和重要性。

根据上述分析，最可能被认为不正确的描述是 C. 算法必须要有输入和输出。虽然大多数算法确实涉及
输入和输出，但这并非算法的绝对要求。因此，C 选项是这个问题的答案。

24.分治法所能解决的问题应具有的关键特征是（）
A．该问题的规模缩小到一定的程度就可以容易地解决
B．该问题可以分解为若干个规模较小的相同问题
C．利用该问题分解出的子问题的解可以合并为该问题的解
D．该问题所分解出的各个子问题是相互独立的
答案：C
解析：
分治法是一种重要的算法设计策略，主要用于解决复杂问题。这种方法的核心是将大问题分解成若干个小问题，
单独解决这些小问题，然后将解决方案合并以解决原来的大问题。我们来逐一分析给出的选项：

A. 该问题的规模缩小到一定的程度就可以容易地解决：这个描述是分治法的一个特征，但它不是分治法的关键特征。
小规模问题更容易解决是许多算法共有的特性，并非分治法特有。
B. 该问题可以分解为若干个规模较小的相同问题：这是分治法的一个重要特征。将大问题分解为多个小问题是分治
法的核心步骤之一。
C. 利用该问题分解出的子问题的解可以合并为该问题的解：这是分治法的关键特征。分治法的核心不仅在于分解问题，
还在于能够将子问题的解有效地合并成原问题的解。
D. 该问题所分解出的各个子问题是相互独立的：这也是分治法的一个重要特征，因为它使得子问题可以独立解决，
甚至可以并行处理。
虽然所有这些选项都描述了分治法的某些特征，但关键在于如何将子问题的解合并成原问题的解。因此，选项 C 
是最准确的答案。在分治法中，能否将子问题的解有效组合成原问题的解是整个策略成功与否的关键。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="期末考试要点"><a class="header" href="#期末考试要点">期末考试要点</a></h2>
<p>考核时长120分钟。考核结束后可以讨论。</p>
<p>1、填空题（10分，5道题，每道题2分，都是单选）</p>
<p>2、选择题（10分，5道题，每道题2分）</p>
<p>前两部分均是考察基础概念。</p>
<p>3、应用题（3～6题，都是20分1题，一共80分）</p>
<ul>
<li>题1，第二章的分治</li>
</ul>
<p>关键词</p>
<p>1、分治过程（初始状态，第1趟状态，第n躺状态）</p>
<p>2、分治的算法分析，分析时间复杂度（数学推理/图示）</p>
<ul>
<li>题2，第三章的动态规划</li>
</ul>
<p>关键词</p>
<p>1、找到状态（小明爬楼梯例子），状态表达的变量/属性</p>
<p>2、状态转移方程（核心，初始状态、结束状态、过程中一般的状态）</p>
<p>3、边界情况</p>
<p>4、函数的编写（根据状态转移方程翻译为代码，用c++或者伪代码，将状态转移方程表达出来）</p>
<ul>
<li>题3，第四章贪心</li>
</ul>
<p>关键词</p>
<p>1、思路，构造局部最优的策略</p>
<p>2、时间复杂度（关键步骤在哪里）</p>
<ul>
<li>题4，第五章回溯</li>
</ul>
<p>关键词</p>
<p>1、解空间，构造是关键</p>
<p>2、两个基本的类型（a.子集树 b.排列树）</p>
<p>注：</p>
<p>1、画出树，解结构的形态</p>
<p>2、求解最优，并解释表达的内涵</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="期末复习笔记1"><a class="header" href="#期末复习笔记1">期末复习笔记（1）</a></h1>
<p>5道选择和5道填空大部分集中在</p>
<ul>
<li>
<p>第1章：基础知识</p>
</li>
<li>
<p>第6章：线性规划</p>
</li>
<li>
<p>第7章：网络流算法</p>
</li>
<li>
<p>第8章：算法分析和问题的计算复杂度</p>
</li>
<li>
<p>第9章：NP完全性</p>
</li>
</ul>
<p>4道大题集中于</p>
<ul>
<li>
<p>第2章分治策略</p>
</li>
<li>
<p>第3章动态规划</p>
</li>
<li>
<p>第4章贪心算法</p>
</li>
<li>
<p>第5章回溯和分支限界</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
