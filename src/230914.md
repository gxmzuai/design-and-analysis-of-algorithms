一、课程主要内容

![](https://vip2.loli.io/2023/09/14/UcAebSnJOHPa8RW.webp)

二、本节课的主要内容

![](https://vip2.loli.io/2023/09/14/2UX4wuavthDNZCH.webp)

三、算法设计的要点

![](https://vip2.loli.io/2023/09/14/pZVkQmdsGRbl4qH.webp)

四、本节课涉及的问题

- 货郎问题

- 0-1背包问题

- 双机调度问题

- NP-hard问题

![](https://vip2.loli.io/2023/09/14/KvhwMZWxic8rBNl.webp)

- .......

五、货郎问题

注：课后作业要用到。

![](https://vip2.loli.io/2023/09/14/6OYavZ2cfAJVETF.webp)

![](https://vip2.loli.io/2023/09/14/Hr5cKaY2N8kLxUl.webp)

六：算法的两种时间复杂度

最坏时间复杂度和平均时间复杂度。

![](https://vip2.loli.io/2023/09/14/ncWLdkXtU2B7g3I.webp)

七、算法的伪代码描述

![](https://vip2.loli.io/2023/09/14/f9LVUwrFC5PAgRN.webp)

八、函数的渐近的界

- 大O符号（描述一个函数的“上界”）

![](https://vip2.loli.io/2023/09/14/Vck1Ew9dWMo8U7K.webp)

![](https://vip2.loli.io/2023/09/14/6ro94VvIYeNq5ab.webp)

- Ω符号（描述一个函数的“下界”）

![](https://vip2.loli.io/2023/09/14/9kjuNTpUiwW3AsQ.webp)

![](https://vip2.loli.io/2023/09/14/DvLnB1jXyYFoZu4.webp)

- 小o符号（描述一个更“严格”的上界）

![](https://vip2.loli.io/2023/09/14/DyjFRrNfZsVnGci.webp)

![](https://vip2.loli.io/2023/09/14/oq7ydfetbZ2pa5L.webp)

- 小Ω符号（描述一个更“严格”的下界）

![](https://vip2.loli.io/2023/09/14/3kuDgz8F1PWCISn.webp)


课后作业

用python或java简单实现货郎问题(TSP,Traveling Salesman Problem)。

```python
# 导入必要的库
import itertools  # 用于生成排列组合
import math  # 用于数学运算

# 定义计算两点之间距离的函数
def distance(point1, point2):
    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

# 定义暴力解决货郎问题的函数
def tsp_bruteforce(points):
    n = len(points)  # 获取点（城市）的数量
    min_distance = float('inf')  # 初始化最短距离为无穷大
    best_path = None  # 初始化最佳路径为 None

    # 遍历所有可能的路径（排列）
    for path in itertools.permutations(range(n)):
        current_distance = 0  # 初始化当前路径的距离为 0

        # 计算当前路径的总距离
        for i in range(n - 1):
            current_distance += distance(points[path[i]], points[path[i + 1]])

        # 加上返回到起始点的距离
        current_distance += distance(points[path[-1]], points[path[0]])

        # 更新最短距离和最佳路径
        if current_distance < min_distance:
            min_distance = current_distance
            best_path = path

    return best_path, min_distance

# 定义一些点（x, y）来表示城市
points = [(0, 0), (1, 2), (2, 4), (3, 1), (4, 3)]

# 调用函数并获取结果
best_path, min_distance = tsp_bruteforce(points)
print(best_path, min_distance)
```


![](https://vip2.loli.io/2023/09/14/zOurbSoMIapTNwR.webp)

![](https://vip2.loli.io/2023/09/14/4jUJ1REFGVXwDiz.webp)
